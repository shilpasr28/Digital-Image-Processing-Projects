 // This sample code reads in image data from a RAW image file and // writes it into another file// NOTE:	The code assumes that the image is of size 256 x 256 and is in the//			RAW format. You will need to make corresponding changes to//			accommodate images of different sizes and/or types////////////////////////////////////////////// Name : SHILPASHREE RAO// USC ID: 5636765972// EMAIL ID: shilpasr@usc.edu// Submission Date: 2/4/2018// EE569 HW 1////////////////////////////////////////////////#include <stdio.h>#include <iostream>#include <stdlib.h>#include <fstream>#include <vector>#include <algorithm>#include <math.h>using namespace std;int medianFilter(vector<unsigned int>& arr) {	int lenArr = arr.size();	sort(arr.begin(), arr.end());	if(lenArr%2 == 0)		return arr[lenArr/2-1];	else		return arr[lenArr/2];} int meanFilter(vector<unsigned int>& arr) {	int lenArr = arr.size();	unsigned int add = 0;	for(vector<unsigned int>::iterator it = arr.begin(); it != arr.end(); it++){		add += *it;	}	return static_cast<int>(add/lenArr);} int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *f1;	FILE *f2;	FILE *f3;	FILE *f4;	FILE *file;	FILE *file1;	int BytesPerPixel;	int Size = 512;	int windowSize = 5;	int windowSizeM = 5;		// Check for proper syntax	if (argc < 3){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		//cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;		cout << "program_name input_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;		return 0;	}		// Check if image is grayscale or color	if (argc < 4){		BytesPerPixel = 1; // default is grey image	} 	else {		BytesPerPixel = atoi(argv[3]);		// Check if size is specified		if (argc >= 5){			Size = atoi(argv[4]);		}	}	if(argc < 6) {		windowSize = 5;	}	else{		windowSize = atoi(argv[5]);	}		// Allocate image data array	unsigned char OriginalImagedata[Size][Size][BytesPerPixel];	unsigned char Imagedata[Size][Size][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file1=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(OriginalImagedata, sizeof(unsigned char), Size*Size*BytesPerPixel, file1);	fclose(file1);	if (!(file=fopen(argv[2],"rb"))) {		cout << "Cannot open file: " << argv[2] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Size*Size*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	unsigned char medianFiltered[Size][Size][BytesPerPixel];	unsigned int paddedImage[Size+windowSize-1][Size+windowSize-1][BytesPerPixel] = {0};	for(int k = 0; k < 3; k++){		for(int i = 0; i < Size+windowSize-1; i++) {			for(int j = 0; j < Size+windowSize-1; j++) {				paddedImage[i][j][k] = 300;			}		}	} 	for(int k = 0; k < 3; k++){		for(int i = 0; i < Size; i++) {			for(int j = 0; j < Size; j++) {				paddedImage[i+(windowSize-1)/2][j+(windowSize-1)/2][k] = static_cast<unsigned int>(Imagedata[i][j][k]);			}		}	} 	vector<unsigned int> stretchedArray;	for(int k = 0; k < 3; k++){		for(int i = (windowSize-1)/2; i < Size+(windowSize-1)/2; i++) {			for(int j = (windowSize-1)/2; j < Size+(windowSize-1)/2; j++) {				for(int x = -1*((windowSize-1)/2); x <= (windowSize-1)/2; x++) {					for(int y = -1*((windowSize-1)/2); y <= (windowSize-1)/2; y++) {						if(paddedImage[i+x][j+y][k] != 300) 							stretchedArray.push_back(paddedImage[i+x][j+y][k]);					}				}				medianFiltered[i-(windowSize-1)/2][j-(windowSize-1)/2][k] = static_cast<unsigned char>(medianFilter(stretchedArray));				while(!stretchedArray.empty()) {					stretchedArray.pop_back();				}			}		}	}	unsigned char meanFiltered[Size][Size][BytesPerPixel];	for(int k = 0; k < 3; k++){		for(int i = 0; i < Size+windowSizeM-1; i++) {			for(int j = 0; j < Size+windowSizeM-1; j++) {				paddedImage[i][j][k] = 300;			}		}	} 	for(int k = 0; k < 3; k++){		for(int i = 0; i < Size; i++) {			for(int j = 0; j < Size; j++) {				paddedImage[i+(windowSizeM-1)/2][j+(windowSizeM-1)/2][k] = static_cast<unsigned int>(medianFiltered[i][j][k]);			}		}	} 	vector<unsigned int> stretched[BytesPerPixel];	for(int i = (windowSizeM-1)/2; i < Size+(windowSizeM-1)/2; i++) {		for(int j = (windowSizeM-1)/2; j < Size+(windowSizeM-1)/2; j++) {			for(int x = -1*((windowSizeM-1)/2); x <= (windowSizeM-1)/2; x++) {				for(int y = -1*((windowSizeM-1)/2); y <= (windowSizeM-1)/2; y++) {					if(paddedImage[i+x][j+y][0] != 300) 						stretched[0].push_back(paddedImage[i+x][j+y][0]);					if(paddedImage[i+x][j+y][1] != 300) 						stretched[1].push_back(paddedImage[i+x][j+y][1]);					if(paddedImage[i+x][j+y][2] != 300) 						stretched[2].push_back(paddedImage[i+x][j+y][2]);				}			}			meanFiltered[i-(windowSizeM-1)/2][j-(windowSizeM-1)/2][0] = static_cast<unsigned char>(meanFilter(stretched[0]));			while(!stretched[0].empty()) {				stretched[0].pop_back();			}			meanFiltered[i-(windowSizeM-1)/2][j-(windowSizeM-1)/2][1] = medianFiltered[i-(windowSizeM-1)/2][j-(windowSizeM-1)/2][1];			meanFiltered[i-(windowSizeM-1)/2][j-(windowSizeM-1)/2][2] = static_cast<unsigned char>(meanFilter(stretched[2]));			while(!stretched[2].empty()) {				stretched[2].pop_back();			}		}	}	float MSE[] = {0.0, 0.0, 0.0};	float PSNR[BytesPerPixel];	float avgPSNR;	for(int k = 0; k < 3; k++){		for(int i = 0; i < Size; i++){			for(int j = 0; j < Size; j++){				//MSE[k] += static_cast<float>((static_cast<unsigned int>(meanFiltered[i][j][k]) - static_cast<unsigned int>(OriginalImagedata[i][j][k]))^2);				MSE[k] += static_cast<float>(pow(meanFiltered[i][j][k] - OriginalImagedata[i][j][k], 2));			}		}		MSE[k] /= Size*Size;		PSNR[k] = 10.0 * log10(255*255/MSE[k]);		cout << MSE[k] << " " << PSNR[k] << endl;	}	avgPSNR = (PSNR[0] + PSNR[1] + PSNR[2])/3;	cout << avgPSNR;	unsigned char Rchannel_output[Size][Size][1];	unsigned char Gchannel_output[Size][Size][1];	unsigned char BChannel_output[Size][Size][1];	for(int i = 0; i < Size; i++){		for(int j = 0; j < Size; j++){			Rchannel_output[i][j][0] = medianFiltered[i][j][0];			Gchannel_output[i][j][0] = medianFiltered[i][j][1];			BChannel_output[i][j][0] = medianFiltered[i][j][2];		}	}	unsigned int RHistVal[256] = {0};	unsigned int GHistVal[256] = {0};	unsigned int BHistVal[256] = {0};	for(int i = 0; i < Size; i++){		for(int j = 0; j < Size; j++){			RHistVal[Rchannel_output[i][j][0]]++;			GHistVal[Gchannel_output[i][j][0]]++;			BHistVal[BChannel_output[i][j][0]]++;		}	}	ofstream RHistData;	ofstream GHistData;	ofstream BHistData;	ofstream IntensityVal;	RHistData.open ("RHist.dat");	GHistData.open ("GHist.dat");	BHistData.open ("BHist.dat");	IntensityVal.open ("IntensityVal.dat");	for(int i = 0; i < 256; i++){		RHistData << RHistVal[i] << endl;	 	GHistData << GHistVal[i] << endl;	 	BHistData << BHistVal[i] << endl;	 	IntensityVal << i << endl;	 }	 RHistData.close();	 GHistData.close();	 BHistData.close();	// Write image data (filename specified by second argument) from image data matrix	//if (!(file=fopen(argv[2],"wb"))) {	//	cout << "Cannot open file: " << argv[2] << endl;	//	exit(1);	///}	f1 = fopen("Rchannel_output.raw","wb");	fwrite(Rchannel_output, sizeof(unsigned char), Size*Size*1, f1);	fclose(f1);	f2 = fopen("Gchannel_output.raw","wb");	fwrite(Gchannel_output, sizeof(unsigned char), Size*Size*1, f2);	fclose(f2);	f3 = fopen("BChannel_output.raw","wb");		fwrite(BChannel_output, sizeof(unsigned char), Size*Size*1, f3);		fclose(f3);	f4 = fopen("Median+Mean_output.raw","wb");		fwrite(meanFiltered, sizeof(unsigned char), Size*Size*BytesPerPixel, f4);		fclose(f4);	return 0;}