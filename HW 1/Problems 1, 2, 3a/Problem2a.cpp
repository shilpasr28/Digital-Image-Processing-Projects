 // This sample code reads in image data from a RAW image file and // writes it into another file// NOTE:	The code assumes that the image is of size 256 x 256 and is in the//			RAW format. You will need to make corresponding changes to//			accommodate images of different sizes and/or types////////////////////////////////////////////// Name : SHILPASHREE RAO// USC ID: 5636765972// EMAIL ID: shilpasr@usc.edu// Submission Date: 2/4/2018// EE569 HW 1////////////////////////////////////////////////#include <stdio.h>#include <iostream>#include <stdlib.h>#include <math.h>#include <fstream>using namespace std;//Sorting code referred from GeekForGeeks, and modified to include sorting indexesvoid swap(int* a, int* b){	int t = *a;	*a = *b;	*b = t;}int partition (int arr[], int ind[], int low, int high){	int pivot = arr[high]; // pivot	int i = (low - 1); // Index of smaller element	for (int j = low; j <= high- 1; j++)	{		// If current element is smaller than or		// equal to pivot		if (arr[j] <= pivot)		{			i++; // increment index of smaller element			swap(&arr[i], &arr[j]);			swap(&ind[i], &ind[j]);		}	}	swap(&arr[i + 1], &arr[high]);	swap(&ind[i + 1], &ind[high]);	return (i + 1);}void quickSort(int arr[], int ind[], int low, int high){	if (low < high)	{		/* pi is partitioning index, arr[p] is now		at right place */		int pi = partition(arr, ind, low, high);		// Separately sort elements before		// partition and after partition		quickSort(arr, ind, low, pi - 1);		quickSort(arr, ind, pi + 1, high);	}}int main(int argc, char *argv[]){	// Define file pointer and variables	FILE *f1;	FILE *f2;	FILE *f3;	FILE *file;	int BytesPerPixel;	//int Size = 256;	int Height = 256 , Width = 256;		// Check for proper syntax	if (argc < 2){		cout << "Syntax Error - Incorrect Parameter Usage:" << endl;		//cout << "program_name input_image.raw output_image.raw [BytesPerPixel = 1] [Size = 256]" << endl;		cout << "program_name input_image.raw [BytesPerPixel = 1] [Height = 256] [Width = 256]" << endl;		return 0;	}		// Check if image is grayscale or color	if (argc < 3){		BytesPerPixel = 1; // default is grey image	} 	else {		BytesPerPixel = atoi(argv[2]);	}	// Check if height is specified	if (argc == 4) {		Height = atoi(argv[3]);	}	else {		// Check if width is specified		Height = atoi(argv[3]);		Width = atoi(argv[4]);	}		// Allocate image data array	unsigned char Imagedata[Height][Width][BytesPerPixel];	// Read image (filename specified by first argument) into image data matrix	if (!(file=fopen(argv[1],"rb"))) {		cout << "Cannot open file: " << argv[1] <<endl;		exit(1);	}	fread(Imagedata, sizeof(unsigned char), Height*Width*BytesPerPixel, file);	fclose(file);	///////////////////////// INSERT YOUR PROCESSING CODE HERE /////////////////////////	//Part1: Plot histograms	unsigned int histogramBinR[256] = {0};	unsigned int histogramBinG[256] = {0};	unsigned int histogramBinB[256] = {0};	for(int i = 0; i < Height; i++){		for(int j = 0; j < Width; j++){			histogramBinR[Imagedata[i][j][0]]++;			histogramBinG[Imagedata[i][j][1]]++;			histogramBinB[Imagedata[i][j][2]]++;		}	}	ofstream Indata_histR;	ofstream Indata_histG;	ofstream Indata_histB;	Indata_histR.open ("Indata_histR.dat");	Indata_histG.open ("Indata_histG.dat");	Indata_histB.open ("Indata_histB.dat");	for(int i = 0; i < 256; i++){		Indata_histR << histogramBinR[i] << endl;	 	Indata_histG << histogramBinG[i] << endl;	 	Indata_histB << histogramBinB[i] << endl;	 }	 Indata_histR.close();	 Indata_histG.close();	 Indata_histB.close();	//Part 2: Method A	float probabilityR[256], probabilityG[256], probabilityB[256];	float cumProbR[256], cumProbG[256], cumProbB[256];	unsigned char scaledProbR[256], scaledProbG[256], scaledProbB[256];	for(int i = 0; i < 256; i++){		probabilityR[i] = static_cast<float>(histogramBinR[i])/(Height*Width);		probabilityG[i] = static_cast<float>(histogramBinG[i])/(Height*Width);		probabilityB[i] = static_cast<float>(histogramBinB[i])/(Height*Width);  		if(i == 0){			cumProbR[i] = probabilityR[i];			cumProbG[i] = probabilityG[i];			cumProbB[i] = probabilityB[i];		}		else{			cumProbR[i] = probabilityR[i] + cumProbR[i-1];			cumProbG[i] = probabilityG[i] + cumProbG[i-1];			cumProbB[i] = probabilityB[i] + cumProbB[i-1];		}		scaledProbR[i] = static_cast<char>(floor(cumProbR[i] * 255));		scaledProbG[i] = static_cast<char>(floor(cumProbG[i] * 255));		scaledProbB[i] = static_cast<char>(floor(cumProbB[i] * 255));	}	unsigned char outputImageA[Height][Width][BytesPerPixel];	for(int i = 0; i < Height; i++){		for(int j = 0; j < Width; j++){			outputImageA[i][j][0] = scaledProbR[Imagedata[i][j][0]];			outputImageA[i][j][1] = scaledProbG[Imagedata[i][j][1]];			outputImageA[i][j][2] = scaledProbB[Imagedata[i][j][2]];		}	}	unsigned int OutA_HistR[256] = {0};	unsigned int OutA_HistG[256] = {0};	unsigned int OutA_HistB[256] = {0};	for(int i = 0; i < Height; i++){		for(int j = 0; j < Width; j++){			OutA_HistR[outputImageA[i][j][0]]++;			OutA_HistG[outputImageA[i][j][1]]++;			OutA_HistB[outputImageA[i][j][2]]++;		}	}	ofstream OutAdata_histR;	ofstream OutAdata_histG;	ofstream OutAdata_histB;	ofstream IntensityVal;	OutAdata_histR.open ("OutAdata_histR.dat");	OutAdata_histG.open ("OutAdata_histG.dat");	OutAdata_histB.open ("OutAdata_histB.dat");	IntensityVal.open ("IntensityVal.dat");	for(int i = 0; i < 256; i++){		OutAdata_histR << OutA_HistR[i] << endl;	 	OutAdata_histG << OutA_HistG[i] << endl;	 	OutAdata_histB << OutA_HistB[i] << endl;	 	IntensityVal << i << endl;	 }	 OutAdata_histR.close();	 OutAdata_histG.close();	 OutAdata_histB.close();		//Part 3: Method B	int ind, imgind;	int buckets = (Height * Width)/256;	int flattenedMatrix[Height * Width];	int matrixInd[Height * Width];	unsigned char outputImageB[Height][Width][BytesPerPixel];	for(int k = 0; k < 3; k++){		for(int i = 0; i < Height; i++){			for(int j = 0; j < Width; j++){				outputImageB[i][j][k] = Imagedata[i][j][k];				flattenedMatrix[i*Width+j] = static_cast<int>(Imagedata[i][j][k]);			}		}		for(int i = 0; i < Height * Width; i++){	        matrixInd[i] = i;	    }		quickSort(flattenedMatrix, matrixInd, 0, Height * Width - 1);		ind = 0;		for(int i = 0; i < 256; i++){			for(int j = 0; j < buckets; j++){				imgind = matrixInd[ind];				outputImageB[imgind/Width][imgind - Width*(imgind/Width)][k] = static_cast<unsigned char>(i);				ind++;			}		}	}	unsigned int OutB_HistR[256] = {0};	unsigned int OutB_HistG[256] = {0};	unsigned int OutB_HistB[256] = {0};	for(int i = 0; i < Height; i++){		for(int j = 0; j < Width; j++){			OutB_HistR[outputImageB[i][j][0]]++;			OutB_HistG[outputImageB[i][j][1]]++;			OutB_HistB[outputImageB[i][j][2]]++;		}	}	ofstream OutBdata_histR;	ofstream OutBdata_histG;	ofstream OutBdata_histB;	OutBdata_histR.open ("OutBdata_histR.dat");	OutBdata_histG.open ("OutBdata_histG.dat");	OutBdata_histB.open ("OutBdata_histB.dat");	for(int i = 0; i < 256; i++){		OutBdata_histR << OutB_HistR[i] << endl;	 	OutBdata_histG << OutB_HistG[i] << endl;	 	OutBdata_histB << OutB_HistB[i] << endl;	 }	 OutBdata_histR.close();	 OutBdata_histG.close();	 OutBdata_histB.close();		// Write image data (filename specified by second argument) from image data matrix	//if (!(file=fopen(argv[2],"wb"))) {	//	cout << "Cannot open file: " << argv[2] << endl;	//	exit(1);	///}	f1 = fopen("methodA_output.raw","wb");	fwrite(outputImageA, sizeof(unsigned char), Height*Width*BytesPerPixel, f1);	fclose(f1);	f2 = fopen("methodB_output.raw","wb");	fwrite(outputImageB, sizeof(unsigned char), Height*Width*BytesPerPixel, f2);	fclose(f2);	return 0;}